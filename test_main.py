"""Unit tests for main.py - PR Regression Review Cloud Function.

Run with: pytest test_main.py -v
"""

import pytest
from unittest.mock import MagicMock, patch

from google.api_core.exceptions import PreconditionFailed

from main import (
    AzureDevOpsClient,
    save_to_storage,
    get_max_severity,
    build_review_prompt,
    check_and_claim_processing,
    update_marker_completed,
    update_marker_for_retry,
    update_marker_failed,
    MAX_RETRY_ATTEMPTS,
    load_webhook_config,
    receive_webhook,
    process_pr_review,
    ReviewResult,
)


# =============================================================================
# Fixtures
# =============================================================================

@pytest.fixture
def ado_client():
    """Create an AzureDevOpsClient instance for testing."""
    return AzureDevOpsClient(
        org="test-org",
        project="test-project",
        repo="test-repo",
        pat="fake-pat-token",
    )


@pytest.fixture
def sample_pr():
    """Sample PR metadata response."""
    return {
        "pullRequestId": 12345,
        "title": "Add new feature",
        "description": "This PR adds a new feature to the component.",
        "createdBy": {"displayName": "John Doe"},
        "sourceRefName": "refs/heads/feature/new-feature",
        "targetRefName": "refs/heads/main",
        "lastMergeSourceCommit": {"commitId": "abc123def456"},
        "lastMergeTargetCommit": {"commitId": "789xyz000111"},
    }


@pytest.fixture
def sample_file_diffs():
    """Sample file diffs for prompt building."""
    return [
        {
            "path": "/src/component.js",
            "change_type": "edit",
            "source_content": "function newCode() { return true; }",
            "target_content": "function oldCode() { return false; }",
        },
        {
            "path": "/src/styles.css",
            "change_type": "add",
            "source_content": ".new-class { color: red; }",
            "target_content": None,
        },
    ]


# =============================================================================
# ReviewResult Tests
# =============================================================================

class TestReviewResult:
    """Tests for ReviewResult dataclass."""

    def test_review_result_creation(self):
        """ReviewResult can be instantiated with all fields."""
        result = ReviewResult(
            pr_id=12345,
            pr_title="Test PR",
            pr_author="John Doe",
            files_changed=3,
            max_severity="warning",
            has_blocking=False,
            has_warning=True,
            review_text="# Review\n\nSome review text",
            storage_path="gs://bucket/reviews/2026/01/07/pr-12345.md",
            commented=True,
            action_taken="commented",
        )
        
        assert result.pr_id == 12345
        assert result.pr_title == "Test PR"
        assert result.pr_author == "John Doe"
        assert result.files_changed == 3
        assert result.max_severity == "warning"
        assert result.has_blocking is False
        assert result.has_warning is True
        assert "Review" in result.review_text
        assert result.storage_path.startswith("gs://")
        assert result.commented is True
        assert result.action_taken == "commented"

    def test_review_result_no_action(self):
        """ReviewResult with no action (info severity)."""
        result = ReviewResult(
            pr_id=12345,
            pr_title="Clean PR",
            pr_author="Jane Doe",
            files_changed=1,
            max_severity="info",
            has_blocking=False,
            has_warning=False,
            review_text="# Review\n\nNo issues found.",
            storage_path="gs://bucket/reviews/2026/01/07/pr-12345.md",
            commented=False,
            action_taken=None,
        )
        
        assert result.max_severity == "info"
        assert result.commented is False
        assert result.action_taken is None


# =============================================================================
# Core Review Logic Tests
# =============================================================================

class TestProcessPrReview:
    """Tests for process_pr_review shared function."""

    def test_process_review_blocking_severity(self, ado_client, sample_pr, sample_file_diffs, mocker):
        """process_pr_review returns blocking result and posts comment + rejects PR."""
        config = {"GCS_BUCKET": "test-bucket"}
        
        # Mock Gemini to return blocking review
        mock_review = """# PR Review

### Finding: Critical regression
**Severity:** blocking

This change breaks existing functionality."""
        mocker.patch("main.call_gemini", return_value=mock_review)
        mocker.patch("main.save_to_storage", return_value="gs://test-bucket/reviews/pr-12345.md")
        mocker.patch.object(ado_client, "post_pr_comment")
        mocker.patch.object(ado_client, "get_current_user_id", return_value="user-123")
        mocker.patch.object(ado_client, "reject_pr")
        
        result = process_pr_review(config, ado_client, 12345, sample_pr, sample_file_diffs)
        
        assert result.max_severity == "blocking"
        assert result.has_blocking is True
        assert result.commented is True
        assert result.action_taken == "rejected"
        
        # Verify comment was posted with correct header
        ado_client.post_pr_comment.assert_called_once()
        comment_text = ado_client.post_pr_comment.call_args[0][1]
        assert "RAWL9001" in comment_text
        assert "Sorry Dave" in comment_text
        assert "John Doe" in comment_text  # Author name included
        
        # Verify PR was rejected
        ado_client.reject_pr.assert_called_once_with(12345, "user-123")

    def test_process_review_warning_severity(self, ado_client, sample_pr, sample_file_diffs, mocker):
        """process_pr_review returns warning result and posts comment but does not reject."""
        config = {"GCS_BUCKET": "test-bucket"}
        
        mock_review = """# PR Review

### Finding: Potential issue
**Severity:** warning

This might cause problems."""
        mocker.patch("main.call_gemini", return_value=mock_review)
        mocker.patch("main.save_to_storage", return_value="gs://test-bucket/reviews/pr-12345.md")
        mocker.patch.object(ado_client, "post_pr_comment")
        mocker.patch.object(ado_client, "reject_pr")
        
        result = process_pr_review(config, ado_client, 12345, sample_pr, sample_file_diffs)
        
        assert result.max_severity == "warning"
        assert result.has_blocking is False
        assert result.has_warning is True
        assert result.commented is True
        assert result.action_taken == "commented"
        
        # Verify comment was posted
        ado_client.post_pr_comment.assert_called_once()
        comment_text = ado_client.post_pr_comment.call_args[0][1]
        assert "Warning" in comment_text
        
        # Verify PR was NOT rejected
        ado_client.reject_pr.assert_not_called()

    def test_process_review_info_severity(self, ado_client, sample_pr, sample_file_diffs, mocker):
        """process_pr_review returns info result with no actions."""
        config = {"GCS_BUCKET": "test-bucket"}
        
        mock_review = """# PR Review

### Finding: Minor observation
**Severity:** info

Just a note."""
        mocker.patch("main.call_gemini", return_value=mock_review)
        mocker.patch("main.save_to_storage", return_value="gs://test-bucket/reviews/pr-12345.md")
        mocker.patch.object(ado_client, "post_pr_comment")
        mocker.patch.object(ado_client, "reject_pr")
        
        result = process_pr_review(config, ado_client, 12345, sample_pr, sample_file_diffs)
        
        assert result.max_severity == "info"
        assert result.has_blocking is False
        assert result.has_warning is False
        assert result.commented is False
        assert result.action_taken is None
        
        # Verify no comment was posted
        ado_client.post_pr_comment.assert_not_called()
        ado_client.reject_pr.assert_not_called()

    def test_process_review_extracts_pr_metadata(self, ado_client, sample_pr, sample_file_diffs, mocker):
        """process_pr_review extracts title and author from PR metadata."""
        config = {"GCS_BUCKET": "test-bucket"}
        
        mocker.patch("main.call_gemini", return_value="# Review\n**Severity:** info")
        mocker.patch("main.save_to_storage", return_value="gs://bucket/path.md")
        
        result = process_pr_review(config, ado_client, 12345, sample_pr, sample_file_diffs)
        
        assert result.pr_title == "Add new feature"
        assert result.pr_author == "John Doe"
        assert result.files_changed == 2  # sample_file_diffs has 2 files

    def test_process_review_stores_review_text(self, ado_client, sample_pr, sample_file_diffs, mocker):
        """process_pr_review includes full review text in result."""
        config = {"GCS_BUCKET": "test-bucket"}
        
        expected_review = "# Full Review Content\n\nDetailed analysis here."
        mocker.patch("main.call_gemini", return_value=expected_review)
        mocker.patch("main.save_to_storage", return_value="gs://bucket/path.md")
        
        result = process_pr_review(config, ado_client, 12345, sample_pr, sample_file_diffs)
        
        assert result.review_text == expected_review

    def test_process_review_saves_to_storage(self, ado_client, sample_pr, sample_file_diffs, mocker):
        """process_pr_review saves review to cloud storage."""
        config = {"GCS_BUCKET": "my-bucket"}
        
        mocker.patch("main.call_gemini", return_value="# Review")
        mock_save = mocker.patch("main.save_to_storage", return_value="gs://my-bucket/reviews/path.md")
        
        result = process_pr_review(config, ado_client, 12345, sample_pr, sample_file_diffs)
        
        mock_save.assert_called_once_with("my-bucket", 12345, "# Review")
        assert result.storage_path == "gs://my-bucket/reviews/path.md"


# =============================================================================
# AzureDevOpsClient Tests
# =============================================================================

class TestAzureDevOpsClientRequest:
    """Tests for AzureDevOpsClient._request method."""

    def test_request_get_success(self, ado_client, mocker):
        """GET request returns JSON response."""
        mock_response = MagicMock()
        mock_response.status_code = 200
        mock_response.json.return_value = {"id": 1, "name": "test"}
        
        mock_request = mocker.patch("main.requests.request", return_value=mock_response)
        
        result = ado_client._get("/test/endpoint")
        
        mock_request.assert_called_once()
        call_args = mock_request.call_args
        assert call_args[0][0] == "GET"
        assert "/test/endpoint" in call_args[0][1]
        assert result == {"id": 1, "name": "test"}

    def test_request_post_success(self, ado_client, mocker):
        """POST request sends payload and returns JSON."""
        mock_response = MagicMock()
        mock_response.status_code = 201
        mock_response.json.return_value = {"created": True}
        
        mock_request = mocker.patch("main.requests.request", return_value=mock_response)
        
        payload = {"content": "test data"}
        result = ado_client._post("/test/endpoint", payload)
        
        mock_request.assert_called_once()
        call_args = mock_request.call_args
        assert call_args[0][0] == "POST"
        assert call_args[1]["json"] == payload
        assert result == {"created": True}

    def test_request_put_success(self, ado_client, mocker):
        """PUT request sends payload and returns JSON."""
        mock_response = MagicMock()
        mock_response.status_code = 200
        mock_response.json.return_value = {"updated": True}
        
        mock_request = mocker.patch("main.requests.request", return_value=mock_response)
        
        payload = {"vote": -10}
        result = ado_client._put("/test/endpoint", payload)
        
        mock_request.assert_called_once()
        call_args = mock_request.call_args
        assert call_args[0][0] == "PUT"
        assert call_args[1]["json"] == payload
        assert result == {"updated": True}


class TestAzureDevOpsClientMethods:
    """Tests for AzureDevOpsClient high-level methods."""

    def test_get_pull_request(self, ado_client, sample_pr, mocker):
        """get_pull_request fetches PR metadata."""
        mocker.patch.object(ado_client, "_get", return_value=sample_pr)
        
        result = ado_client.get_pull_request(12345)
        
        ado_client._get.assert_called_once_with("/git/repositories/test-repo/pullrequests/12345")
        assert result["pullRequestId"] == 12345
        assert result["title"] == "Add new feature"

    def test_get_file_content(self, ado_client, mocker):
        """get_file_content fetches file at specific commit."""
        mock_response = MagicMock()
        mock_response.status_code = 200
        mock_response.text = "file content here"
        
        mocker.patch("main.requests.get", return_value=mock_response)
        
        result = ado_client.get_file_content("/src/file.js", "abc123")
        
        assert result == "file content here"

    def test_get_pr_diff(self, ado_client, sample_pr, mocker):
        """get_pr_diff aggregates file contents from source and target."""
        mocker.patch.object(ado_client, "get_pull_request", return_value=sample_pr)
        mocker.patch.object(ado_client, "get_pr_changes", return_value=[
            {
                "item": {"path": "/src/test.js", "isFolder": False},
                "changeType": "edit",
            }
        ])
        mocker.patch.object(
            ado_client, 
            "get_file_content", 
            side_effect=["new content", "old content"]
        )
        
        result = ado_client.get_pr_diff(12345)
        
        assert len(result) == 1
        assert result[0]["path"] == "/src/test.js"
        assert result[0]["change_type"] == "edit"
        assert result[0]["source_content"] == "new content"
        assert result[0]["target_content"] == "old content"


# =============================================================================
# Cloud Storage Tests
# =============================================================================

class TestSaveToStorage:
    """Tests for save_to_storage function."""

    def test_save_to_storage_success(self, mocker):
        """save_to_storage uploads review to GCS bucket."""
        mock_blob = MagicMock()
        mock_bucket = MagicMock()
        mock_bucket.blob.return_value = mock_blob
        
        mock_client = MagicMock()
        mock_client.bucket.return_value = mock_bucket
        
        mocker.patch("main.storage.Client", return_value=mock_client)
        
        review_content = "# Review\n\nThis is a test review."
        result = save_to_storage("test-bucket", 12345, review_content)
        
        # Verify bucket was accessed
        mock_client.bucket.assert_called_once_with("test-bucket")
        
        # Verify blob was created with correct path pattern
        blob_call = mock_bucket.blob.call_args[0][0]
        assert blob_call.startswith("reviews/")
        assert "pr-12345" in blob_call
        assert blob_call.endswith("-review.md")
        
        # Verify upload was called
        mock_blob.upload_from_string.assert_called_once_with(
            review_content, 
            content_type="text/markdown"
        )
        
        # Verify return path format
        assert result.startswith("gs://test-bucket/reviews/")


# =============================================================================
# Pure Logic Tests
# =============================================================================

class TestGetMaxSeverity:
    """Tests for get_max_severity function."""

    def test_get_max_severity_blocking(self):
        """Returns 'blocking' when blocking severity found."""
        review = """
        # Review
        
        ### Finding: Critical issue
        **Severity:** blocking
        
        This is a blocking issue.
        """
        assert get_max_severity(review) == "blocking"

    def test_get_max_severity_warning(self):
        """Returns 'warning' when warning severity found (no blocking)."""
        review = """
        # Review
        
        ### Finding: Potential issue
        **Severity:** warning
        
        This could cause problems.
        """
        assert get_max_severity(review) == "warning"

    def test_get_max_severity_info(self):
        """Returns 'info' when no blocking or warning found."""
        review = """
        # Review
        
        ### Finding: Minor note
        **Severity:** info
        
        Just an observation.
        """
        assert get_max_severity(review) == "info"

    def test_get_max_severity_blocking_takes_precedence(self):
        """Returns 'blocking' even when warning is also present."""
        review = """
        # Review
        
        ### Finding: Warning issue
        **Severity:** warning
        
        ### Finding: Critical issue
        **Severity:** blocking
        """
        assert get_max_severity(review) == "blocking"

    def test_get_max_severity_empty_review(self):
        """Returns 'info' for empty review."""
        assert get_max_severity("") == "info"


class TestBuildReviewPrompt:
    """Tests for build_review_prompt function."""

    def test_build_review_prompt(self, sample_pr, sample_file_diffs):
        """build_review_prompt constructs prompt with PR context and diffs."""
        prompt = build_review_prompt(sample_pr, sample_file_diffs)
        
        # Check PR metadata is included
        assert "Add new feature" in prompt
        assert "12345" in prompt
        assert "John Doe" in prompt
        assert "feature/new-feature" in prompt
        assert "main" in prompt
        
        # Check file paths are included
        assert "/src/component.js" in prompt
        assert "/src/styles.css" in prompt
        
        # Check change types are included
        assert "edit" in prompt
        assert "add" in prompt
        
        # Check file contents are included
        assert "function newCode()" in prompt
        assert "function oldCode()" in prompt
        assert ".new-class" in prompt

    def test_build_review_prompt_with_description(self, sample_pr, sample_file_diffs):
        """build_review_prompt includes PR description."""
        prompt = build_review_prompt(sample_pr, sample_file_diffs)
        
        assert "This PR adds a new feature to the component." in prompt

    def test_build_review_prompt_ends_with_instruction(self, sample_pr, sample_file_diffs):
        """build_review_prompt ends with review instruction."""
        prompt = build_review_prompt(sample_pr, sample_file_diffs)
        
        assert prompt.strip().endswith("Please provide your regression-focused review.")


# =============================================================================
# Idempotency Tests
# =============================================================================

class TestCheckAndClaimProcessing:
    """Tests for check_and_claim_processing function."""

    def test_claim_success_when_marker_not_exists(self, mocker):
        """Returns True and creates marker when no existing marker."""
        mock_blob = MagicMock()
        mock_blob.exists.return_value = False
        
        mock_bucket = MagicMock()
        mock_bucket.blob.return_value = mock_blob
        
        mock_client = MagicMock()
        mock_client.bucket.return_value = mock_bucket
        
        mocker.patch("main.storage.Client", return_value=mock_client)
        
        result = check_and_claim_processing("test-bucket", 12345, "abc123def456")
        
        assert result is True
        mock_bucket.blob.assert_called_once_with("idempotency/pr-12345-abc123def456.json")
        mock_blob.upload_from_string.assert_called_once()
        
        # Verify atomic write was used
        call_kwargs = mock_blob.upload_from_string.call_args[1]
        assert call_kwargs["if_generation_match"] == 0
        assert call_kwargs["content_type"] == "application/json"

    def test_skip_when_marker_completed(self, mocker):
        """Returns False when marker exists with completed status."""
        import json
        
        mock_blob = MagicMock()
        mock_blob.exists.return_value = True
        mock_blob.download_as_text.return_value = json.dumps({
            "pr_id": 12345,
            "commit_sha": "abc123def456",
            "status": "completed"
        })
        
        mock_bucket = MagicMock()
        mock_bucket.blob.return_value = mock_blob
        
        mock_client = MagicMock()
        mock_client.bucket.return_value = mock_bucket
        
        mocker.patch("main.storage.Client", return_value=mock_client)
        
        result = check_and_claim_processing("test-bucket", 12345, "abc123def456")
        
        assert result is False
        mock_blob.upload_from_string.assert_not_called()

    def test_skip_when_marker_failed(self, mocker):
        """Returns False when marker exists with failed status."""
        import json
        
        mock_blob = MagicMock()
        mock_blob.exists.return_value = True
        mock_blob.download_as_text.return_value = json.dumps({
            "pr_id": 12345,
            "commit_sha": "abc123def456",
            "status": "failed",
            "retry_count": 3
        })
        
        mock_bucket = MagicMock()
        mock_bucket.blob.return_value = mock_blob
        
        mock_client = MagicMock()
        mock_client.bucket.return_value = mock_bucket
        
        mocker.patch("main.storage.Client", return_value=mock_client)
        
        result = check_and_claim_processing("test-bucket", 12345, "abc123def456")
        
        assert result is False

    def test_allow_retry_when_processing_under_limit(self, mocker):
        """Returns True when marker is processing and retry_count < MAX."""
        import json
        
        mock_blob = MagicMock()
        mock_blob.exists.return_value = True
        mock_blob.download_as_text.return_value = json.dumps({
            "pr_id": 12345,
            "commit_sha": "abc123def456",
            "status": "processing",
            "retry_count": 1
        })
        
        mock_bucket = MagicMock()
        mock_bucket.blob.return_value = mock_blob
        
        mock_client = MagicMock()
        mock_client.bucket.return_value = mock_bucket
        
        mocker.patch("main.storage.Client", return_value=mock_client)
        
        result = check_and_claim_processing("test-bucket", 12345, "abc123def456")
        
        assert result is True

    def test_skip_when_max_retries_exceeded(self, mocker):
        """Returns False when marker is processing but retry_count >= MAX."""
        import json
        
        mock_blob = MagicMock()
        mock_blob.exists.return_value = True
        mock_blob.download_as_text.return_value = json.dumps({
            "pr_id": 12345,
            "commit_sha": "abc123def456",
            "status": "processing",
            "retry_count": MAX_RETRY_ATTEMPTS
        })
        
        mock_bucket = MagicMock()
        mock_bucket.blob.return_value = mock_blob
        
        mock_client = MagicMock()
        mock_client.bucket.return_value = mock_bucket
        
        mocker.patch("main.storage.Client", return_value=mock_client)
        
        result = check_and_claim_processing("test-bucket", 12345, "abc123def456")
        
        assert result is False

    def test_skip_on_race_condition(self, mocker):
        """Returns False when another instance claimed marker (PreconditionFailed)."""
        mock_blob = MagicMock()
        mock_blob.exists.return_value = False
        mock_blob.upload_from_string.side_effect = PreconditionFailed("Precondition failed")
        
        mock_bucket = MagicMock()
        mock_bucket.blob.return_value = mock_blob
        
        mock_client = MagicMock()
        mock_client.bucket.return_value = mock_bucket
        
        mocker.patch("main.storage.Client", return_value=mock_client)
        
        result = check_and_claim_processing("test-bucket", 12345, "abc123def456")
        
        assert result is False

    def test_marker_content_format(self, mocker):
        """Marker JSON contains expected fields."""
        import json
        
        mock_blob = MagicMock()
        mock_blob.exists.return_value = False
        
        mock_bucket = MagicMock()
        mock_bucket.blob.return_value = mock_blob
        
        mock_client = MagicMock()
        mock_client.bucket.return_value = mock_bucket
        
        mocker.patch("main.storage.Client", return_value=mock_client)
        
        check_and_claim_processing("test-bucket", 12345, "abc123def456")
        
        # Get the JSON content that was uploaded
        uploaded_content = mock_blob.upload_from_string.call_args[0][0]
        marker = json.loads(uploaded_content)
        
        assert marker["pr_id"] == 12345
        assert marker["commit_sha"] == "abc123def456"
        assert marker["status"] == "processing"
        assert marker["retry_count"] == 0
        assert "claimed_at" in marker


class TestUpdateMarkerCompleted:
    """Tests for update_marker_completed function."""

    def test_update_marker_success(self, mocker):
        """Updates marker with completion status."""
        import json
        
        mock_blob = MagicMock()
        mock_bucket = MagicMock()
        mock_bucket.blob.return_value = mock_blob
        
        mock_client = MagicMock()
        mock_client.bucket.return_value = mock_bucket
        
        mocker.patch("main.storage.Client", return_value=mock_client)
        
        update_marker_completed("test-bucket", 12345, "abc123def456", "warning", True)
        
        mock_bucket.blob.assert_called_once_with("idempotency/pr-12345-abc123def456.json")
        mock_blob.upload_from_string.assert_called_once()
        
        # Verify marker content
        uploaded_content = mock_blob.upload_from_string.call_args[0][0]
        marker = json.loads(uploaded_content)
        
        assert marker["pr_id"] == 12345
        assert marker["commit_sha"] == "abc123def456"
        assert marker["status"] == "completed"
        assert marker["max_severity"] == "warning"
        assert marker["commented"] is True
        assert "processed_at" in marker


class TestUpdateMarkerForRetry:
    """Tests for update_marker_for_retry function."""

    def test_first_retry_returns_true(self, mocker):
        """Returns True on first retry (retry_count < MAX)."""
        import json
        
        mock_blob = MagicMock()
        mock_blob.exists.return_value = True
        mock_blob.download_as_text.return_value = json.dumps({
            "pr_id": 12345,
            "commit_sha": "abc123def456",
            "status": "processing",
            "retry_count": 0
        })
        
        mock_bucket = MagicMock()
        mock_bucket.blob.return_value = mock_blob
        
        mock_client = MagicMock()
        mock_client.bucket.return_value = mock_bucket
        
        mocker.patch("main.storage.Client", return_value=mock_client)
        
        result = update_marker_for_retry("test-bucket", 12345, "abc123def456", "Test error")
        
        assert result is True
        
        # Verify marker was updated with incremented retry_count
        uploaded_content = mock_blob.upload_from_string.call_args[0][0]
        marker = json.loads(uploaded_content)
        assert marker["retry_count"] == 1
        assert marker["status"] == "processing"

    def test_max_retries_returns_false(self, mocker):
        """Returns False when max retries exceeded."""
        import json
        
        mock_blob = MagicMock()
        mock_blob.exists.return_value = True
        mock_blob.download_as_text.return_value = json.dumps({
            "pr_id": 12345,
            "commit_sha": "abc123def456",
            "status": "processing",
            "retry_count": MAX_RETRY_ATTEMPTS - 1  # One more will exceed
        })
        
        mock_bucket = MagicMock()
        mock_bucket.blob.return_value = mock_blob
        
        mock_client = MagicMock()
        mock_client.bucket.return_value = mock_bucket
        
        mocker.patch("main.storage.Client", return_value=mock_client)
        
        result = update_marker_for_retry("test-bucket", 12345, "abc123def456", "Test error")
        
        assert result is False
        
        # Verify marker was updated with failed status
        uploaded_content = mock_blob.upload_from_string.call_args[0][0]
        marker = json.loads(uploaded_content)
        assert marker["status"] == "failed"
        assert marker["retry_count"] == MAX_RETRY_ATTEMPTS

    def test_no_existing_marker_starts_at_one(self, mocker):
        """Starts retry_count at 1 when no existing marker."""
        import json
        
        mock_blob = MagicMock()
        mock_blob.exists.return_value = False
        
        mock_bucket = MagicMock()
        mock_bucket.blob.return_value = mock_blob
        
        mock_client = MagicMock()
        mock_client.bucket.return_value = mock_bucket
        
        mocker.patch("main.storage.Client", return_value=mock_client)
        
        result = update_marker_for_retry("test-bucket", 12345, "abc123def456", "Test error")
        
        assert result is True
        
        uploaded_content = mock_blob.upload_from_string.call_args[0][0]
        marker = json.loads(uploaded_content)
        assert marker["retry_count"] == 1


class TestUpdateMarkerFailed:
    """Tests for update_marker_failed function."""

    def test_marks_as_permanently_failed(self, mocker):
        """Creates marker with failed status and non_retryable reason."""
        import json
        
        mock_blob = MagicMock()
        mock_bucket = MagicMock()
        mock_bucket.blob.return_value = mock_blob
        
        mock_client = MagicMock()
        mock_client.bucket.return_value = mock_bucket
        
        mocker.patch("main.storage.Client", return_value=mock_client)
        
        update_marker_failed("test-bucket", 12345, "abc123def456", "401 Unauthorized")
        
        mock_bucket.blob.assert_called_once_with("idempotency/pr-12345-abc123def456.json")
        
        uploaded_content = mock_blob.upload_from_string.call_args[0][0]
        marker = json.loads(uploaded_content)
        
        assert marker["pr_id"] == 12345
        assert marker["commit_sha"] == "abc123def456"
        assert marker["status"] == "failed"
        assert marker["reason"] == "non_retryable_error"
        assert marker["error"] == "401 Unauthorized"
        assert "failed_at" in marker

    def test_truncates_long_error_messages(self, mocker):
        """Truncates error messages longer than 500 chars."""
        import json
        
        mock_blob = MagicMock()
        mock_bucket = MagicMock()
        mock_bucket.blob.return_value = mock_blob
        
        mock_client = MagicMock()
        mock_client.bucket.return_value = mock_bucket
        
        mocker.patch("main.storage.Client", return_value=mock_client)
        
        long_error = "x" * 1000
        update_marker_failed("test-bucket", 12345, "abc123def456", long_error)
        
        uploaded_content = mock_blob.upload_from_string.call_args[0][0]
        marker = json.loads(uploaded_content)
        
        assert len(marker["error"]) == 500


class TestIdempotencyKeyFormat:
    """Tests verifying the idempotency key format."""

    def test_different_commits_same_pr_have_different_keys(self, mocker):
        """Same PR with different commits creates different marker paths."""
        mock_blob = MagicMock()
        mock_blob.exists.return_value = False
        
        mock_bucket = MagicMock()
        mock_bucket.blob.return_value = mock_blob
        
        mock_client = MagicMock()
        mock_client.bucket.return_value = mock_bucket
        
        mocker.patch("main.storage.Client", return_value=mock_client)
        
        # First commit
        check_and_claim_processing("test-bucket", 12345, "commit_a")
        first_call_path = mock_bucket.blob.call_args_list[0][0][0]
        
        # Second commit (same PR)
        check_and_claim_processing("test-bucket", 12345, "commit_b")
        second_call_path = mock_bucket.blob.call_args_list[1][0][0]
        
        assert first_call_path != second_call_path
        assert "pr-12345-commit_a" in first_call_path
        assert "pr-12345-commit_b" in second_call_path

    def test_same_commit_different_prs_have_different_keys(self, mocker):
        """Same commit on different PRs creates different marker paths."""
        mock_blob = MagicMock()
        mock_blob.exists.return_value = False
        
        mock_bucket = MagicMock()
        mock_bucket.blob.return_value = mock_blob
        
        mock_client = MagicMock()
        mock_client.bucket.return_value = mock_bucket
        
        mocker.patch("main.storage.Client", return_value=mock_client)
        
        # First PR
        check_and_claim_processing("test-bucket", 11111, "same_commit")
        first_call_path = mock_bucket.blob.call_args_list[0][0][0]
        
        # Second PR (same commit SHA - edge case)
        check_and_claim_processing("test-bucket", 22222, "same_commit")
        second_call_path = mock_bucket.blob.call_args_list[1][0][0]
        
        assert first_call_path != second_call_path
        assert "pr-11111" in first_call_path
        assert "pr-22222" in second_call_path


# =============================================================================
# Webhook Receiver Tests
# =============================================================================

class TestLoadWebhookConfig:
    """Tests for load_webhook_config function."""

    def test_load_webhook_config_success(self, mocker):
        """Returns config dict when all required vars present."""
        mocker.patch.dict("os.environ", {
            "API_KEY": "test-api-key",
            "VERTEX_PROJECT": "test-project",
        })
        
        config, missing = load_webhook_config()
        
        assert missing == []
        assert config["API_KEY"] == "test-api-key"
        assert config["VERTEX_PROJECT"] == "test-project"
        assert config["PUBSUB_TOPIC"] == "pr-review-trigger"  # default

    def test_load_webhook_config_custom_topic(self, mocker):
        """Uses custom PUBSUB_TOPIC when provided."""
        mocker.patch.dict("os.environ", {
            "API_KEY": "test-api-key",
            "VERTEX_PROJECT": "test-project",
            "PUBSUB_TOPIC": "custom-topic",
        })
        
        config, missing = load_webhook_config()
        
        assert config["PUBSUB_TOPIC"] == "custom-topic"

    def test_load_webhook_config_missing_vars(self, mocker):
        """Returns missing vars list when required vars missing."""
        mocker.patch.dict("os.environ", {}, clear=True)
        
        config, missing = load_webhook_config()
        
        assert "API_KEY" in missing
        assert "VERTEX_PROJECT" in missing


class TestReceiveWebhook:
    """Tests for receive_webhook function."""

    @pytest.fixture
    def mock_request(self, mocker):
        """Create a mock Flask request object."""
        request = MagicMock()
        request.headers = {}
        request.get_json = MagicMock(return_value={})
        return request

    def test_missing_api_key_header(self, mock_request, mocker):
        """Returns 401 when X-API-Key header is missing."""
        mocker.patch.dict("os.environ", {
            "API_KEY": "test-api-key",
            "VERTEX_PROJECT": "test-project",
        })
        mock_request.headers = {}
        
        response, status = receive_webhook(mock_request)
        
        assert status == 401
        assert "Missing X-API-Key" in response["error"]

    def test_invalid_api_key(self, mock_request, mocker):
        """Returns 401 when API key doesn't match."""
        mocker.patch.dict("os.environ", {
            "API_KEY": "correct-key",
            "VERTEX_PROJECT": "test-project",
        })
        mock_request.headers = {"X-API-Key": "wrong-key"}
        
        response, status = receive_webhook(mock_request)
        
        assert status == 401
        assert "Invalid API key" in response["error"]

    def test_missing_pr_id(self, mock_request, mocker):
        """Returns 400 when pr_id is missing."""
        mocker.patch.dict("os.environ", {
            "API_KEY": "test-key",
            "VERTEX_PROJECT": "test-project",
        })
        mock_request.headers = {"X-API-Key": "test-key"}
        mock_request.get_json.return_value = {"commit_sha": "abc123def"}
        
        response, status = receive_webhook(mock_request)
        
        assert status == 400
        assert "pr_id" in response["error"]

    def test_missing_commit_sha(self, mock_request, mocker):
        """Returns 400 when commit_sha is missing."""
        mocker.patch.dict("os.environ", {
            "API_KEY": "test-key",
            "VERTEX_PROJECT": "test-project",
        })
        mock_request.headers = {"X-API-Key": "test-key"}
        mock_request.get_json.return_value = {"pr_id": 12345}
        
        response, status = receive_webhook(mock_request)
        
        assert status == 400
        assert "commit_sha" in response["error"]

    def test_invalid_pr_id_type(self, mock_request, mocker):
        """Returns 400 when pr_id is not a valid integer."""
        mocker.patch.dict("os.environ", {
            "API_KEY": "test-key",
            "VERTEX_PROJECT": "test-project",
        })
        mock_request.headers = {"X-API-Key": "test-key"}
        mock_request.get_json.return_value = {"pr_id": "not-a-number", "commit_sha": "abc123def"}
        
        response, status = receive_webhook(mock_request)
        
        assert status == 400
        assert "integer" in response["error"]

    def test_commit_sha_too_short(self, mock_request, mocker):
        """Returns 400 when commit_sha is too short."""
        mocker.patch.dict("os.environ", {
            "API_KEY": "test-key",
            "VERTEX_PROJECT": "test-project",
        })
        mock_request.headers = {"X-API-Key": "test-key"}
        mock_request.get_json.return_value = {"pr_id": 12345, "commit_sha": "abc"}
        
        response, status = receive_webhook(mock_request)
        
        assert status == 400
        assert "7 characters" in response["error"]

    def test_successful_publish(self, mock_request, mocker):
        """Returns 202 and publishes to Pub/Sub on success."""
        mocker.patch.dict("os.environ", {
            "API_KEY": "test-key",
            "VERTEX_PROJECT": "test-project",
            "PUBSUB_TOPIC": "test-topic",
        })
        mock_request.headers = {"X-API-Key": "test-key"}
        mock_request.get_json.return_value = {
            "pr_id": 12345,
            "commit_sha": "abc123def456789"
        }
        
        # Mock Pub/Sub client
        mock_future = MagicMock()
        mock_future.result.return_value = "message-id-123"
        
        mock_publisher = MagicMock()
        mock_publisher.topic_path.return_value = "projects/test-project/topics/test-topic"
        mock_publisher.publish.return_value = mock_future
        
        mocker.patch("main.pubsub_v1.PublisherClient", return_value=mock_publisher)
        
        response, status = receive_webhook(mock_request)
        
        assert status == 202
        assert response["status"] == "queued"
        assert response["message_id"] == "message-id-123"
        assert response["pr_id"] == 12345
        assert response["commit_sha"] == "abc123de"  # truncated to 8 chars
        
        # Verify Pub/Sub was called correctly
        mock_publisher.topic_path.assert_called_once_with("test-project", "test-topic")
        mock_publisher.publish.assert_called_once()

    def test_pubsub_message_format(self, mock_request, mocker):
        """Verifies the Pub/Sub message contains expected fields."""
        import json
        
        mocker.patch.dict("os.environ", {
            "API_KEY": "test-key",
            "VERTEX_PROJECT": "test-project",
        })
        mock_request.headers = {"X-API-Key": "test-key"}
        mock_request.get_json.return_value = {
            "pr_id": 12345,
            "commit_sha": "abc123def456789"
        }
        
        mock_future = MagicMock()
        mock_future.result.return_value = "msg-123"
        
        mock_publisher = MagicMock()
        mock_publisher.topic_path.return_value = "projects/test-project/topics/pr-review-trigger"
        mock_publisher.publish.return_value = mock_future
        
        mocker.patch("main.pubsub_v1.PublisherClient", return_value=mock_publisher)
        
        receive_webhook(mock_request)
        
        # Get the message bytes that were published
        publish_call = mock_publisher.publish.call_args
        message_bytes = publish_call[0][1]  # Second positional arg
        message = json.loads(message_bytes.decode("utf-8"))
        
        assert message["pr_id"] == 12345
        assert message["commit_sha"] == "abc123def456789"
        assert message["source"] == "azure-devops-pipeline"
        assert "received_at" in message

    def test_pubsub_publish_failure(self, mock_request, mocker):
        """Returns 500 when Pub/Sub publish fails."""
        mocker.patch.dict("os.environ", {
            "API_KEY": "test-key",
            "VERTEX_PROJECT": "test-project",
        })
        mock_request.headers = {"X-API-Key": "test-key"}
        mock_request.get_json.return_value = {
            "pr_id": 12345,
            "commit_sha": "abc123def456789"
        }
        
        mock_publisher = MagicMock()
        mock_publisher.topic_path.return_value = "projects/test-project/topics/test-topic"
        mock_publisher.publish.side_effect = Exception("Pub/Sub error")
        
        mocker.patch("main.pubsub_v1.PublisherClient", return_value=mock_publisher)
        
        response, status = receive_webhook(mock_request)
        
        assert status == 500
        assert "Failed to queue" in response["error"]

    def test_server_config_error(self, mock_request, mocker):
        """Returns 500 when server config is missing."""
        mocker.patch.dict("os.environ", {}, clear=True)
        
        response, status = receive_webhook(mock_request)
        
        assert status == 500
        assert "configuration error" in response["error"]

    def test_invalid_json_body(self, mock_request, mocker):
        """Returns 400 when request body is not valid JSON."""
        mocker.patch.dict("os.environ", {
            "API_KEY": "test-key",
            "VERTEX_PROJECT": "test-project",
        })
        mock_request.headers = {"X-API-Key": "test-key"}
        mock_request.get_json.side_effect = Exception("Invalid JSON")
        
        response, status = receive_webhook(mock_request)
        
        assert status == 400
        assert "Invalid JSON" in response["error"]

    def test_empty_request_body(self, mock_request, mocker):
        """Returns 400 when request body is empty."""
        mocker.patch.dict("os.environ", {
            "API_KEY": "test-key",
            "VERTEX_PROJECT": "test-project",
        })
        mock_request.headers = {"X-API-Key": "test-key"}
        mock_request.get_json.return_value = None
        
        response, status = receive_webhook(mock_request)
        
        assert status == 400
        assert "Empty" in response["error"]

    def test_pr_id_as_string_integer(self, mock_request, mocker):
        """Accepts pr_id as string that can be parsed as integer."""
        mocker.patch.dict("os.environ", {
            "API_KEY": "test-key",
            "VERTEX_PROJECT": "test-project",
        })
        mock_request.headers = {"X-API-Key": "test-key"}
        mock_request.get_json.return_value = {
            "pr_id": "12345",  # String, not int
            "commit_sha": "abc123def456789"
        }
        
        mock_future = MagicMock()
        mock_future.result.return_value = "msg-123"
        
        mock_publisher = MagicMock()
        mock_publisher.topic_path.return_value = "projects/test-project/topics/test-topic"
        mock_publisher.publish.return_value = mock_future
        
        mocker.patch("main.pubsub_v1.PublisherClient", return_value=mock_publisher)
        
        response, status = receive_webhook(mock_request)
        
        assert status == 202
        assert response["pr_id"] == 12345  # Converted to int

